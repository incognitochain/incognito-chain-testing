{
  "language": "Solidity",
  "sources": {
    "contracts/IERC20.sol": {
      "content": "pragma solidity ^0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint amount) external;\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint amount) external;\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint amount) external;\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() external view returns (uint);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n"
    },
    "contracts/uniswap_trade.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport './trade_utils.sol';\nimport './IERC20.sol';\nimport \"hardhat/console.sol\";\n\ninterface UniswapV2 {\n  function factory() external pure returns (address);\n  function WETH() external pure returns (address);\n\n  function swapExactTokensForTokens(\n      uint amountIn,\n      uint amountOutMin,\n      address[] calldata path,\n      address to,\n      uint deadline\n  ) external returns (uint[] memory amounts);\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n      external\n      payable\n      returns (uint[] memory amounts);\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n      external\n      returns (uint[] memory amounts);\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ncontract UniswapV2Trade is TradeUtils {\n    // Variables\n    UniswapV2 public uniswapV2;\n    address public wETH;\n\n    // Functions\n    /**\n     * @dev Contract constructor\n     * @param _uniswapV2 uniswap routes contract address\n     */\n    constructor(UniswapV2 _uniswapV2) public {\n        uniswapV2 = _uniswapV2;\n        wETH = uniswapV2.WETH();\n    }\n\n    // Reciever function which allows transfer eth.\n    receive() external payable {}\n\n    function trade(IERC20 srcToken, uint srcQty, IERC20 destToken, uint amountOutMin) public payable returns (address, uint) {\n        console.log(\"TRY\");\n        // console.log(\"%s\", address(this).balance);\n        // console.log(\"%s\", srcToken);\n        // console.log(\"%s\", srcQty);\n        require(balanceOf(srcToken) >= srcQty);\n        require(srcToken != destToken);\n        address[] memory path = new address[](2);\n        uint[] memory amounts;\n        if (srcToken != ETH_CONTRACT_ADDRESS) {\n            path[0] = address(srcToken);\n            // approve\n            approve(srcToken, address(uniswapV2), srcQty);\n            if (destToken != ETH_CONTRACT_ADDRESS) { // token to token.\n                path[1] = address(destToken);\n                amounts = tokenToToken(path, srcQty, amountOutMin);\n            } else {\n                path[1] = address(wETH);\n                amounts = tokenToEth(path, srcQty, amountOutMin);\n            }\n        } else {\n            path[0] = address(wETH);\n            path[1] = address(destToken);\n            amounts = ethToToken(path, srcQty, amountOutMin);\n        }\n        require(amounts.length >= 2);\n        require(amounts[amounts.length - 1] >= amountOutMin && amounts[0] == srcQty);\n        return (address(destToken), amounts[amounts.length - 1]);\n    }\n\n    function ethToToken(address[] memory path, uint srcQty, uint amountOutMin) internal returns (uint[] memory) {\n        return uniswapV2.swapExactETHForTokens{value: srcQty}(amountOutMin, path, msg.sender, now + 600);\n    }\n\n    function tokenToEth(address[] memory path, uint srcQty, uint amountOutMin) internal returns (uint[] memory) {\n        return uniswapV2.swapExactTokensForETH(srcQty, amountOutMin, path, msg.sender, now + 600);\n    }\n\n    function tokenToToken(address[] memory path, uint srcQty, uint amountOutMin) internal returns (uint[] memory) {\n        return uniswapV2.swapExactTokensForTokens(srcQty, amountOutMin, path, msg.sender, now + 600);\n    }\n\n    /**\n     * @dev Given an input asset amount and an array of token addresses, calculates all subsequent maximum output token.\n     * @param srcToken source token contract address\n     * @param srcQty amount of source tokens\n     * @param destToken destination token contract address\n     */\n    function getAmountsOut(address srcToken, uint srcQty, address destToken) external view returns(uint[] memory) {\n        address[] memory path = new address[](2);\n        path[0] = srcToken;\n        path[1] = destToken;\n        return uniswapV2.getAmountsOut(srcQty, path);\n    }\n}\n"
    },
    "contracts/trade_utils.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport './IERC20.sol';\n\ncontract TradeUtils {\n\tIERC20 constant public ETH_CONTRACT_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);\n\n\tfunction balanceOf(IERC20 token) internal view returns (uint256) {\n\t\tif (token == ETH_CONTRACT_ADDRESS) {\n\t\t\treturn address(this).balance;\n\t\t}\n        return token.balanceOf(address(this));\n    }\n\n\tfunction transfer(IERC20 token, uint amount) internal {\n\t\tif (token == ETH_CONTRACT_ADDRESS) {\n\t\t\trequire(address(this).balance >= amount);\n\t\t\t(bool success, ) = msg.sender.call{value: amount}(\"\");\n          \trequire(success);\n\t\t} else {\n\t\t\ttoken.transfer(msg.sender, amount);\n\t\t\trequire(checkSuccess());\n\t\t}\n\t}\n\n\tfunction approve(IERC20 token, address proxy, uint amount) internal {\n\t\tif (token != ETH_CONTRACT_ADDRESS) {\n\t\t\ttoken.approve(proxy, 0);\n\t\t\trequire(checkSuccess());\n\t\t\ttoken.approve(proxy, amount);\n\t\t\trequire(checkSuccess());\n\t\t}\n\t}\n\n\t/**\n     * @dev Check if transfer() and transferFrom() of ERC20 succeeded or not\n     * This check is needed to fix https://github.com/ethereum/solidity/issues/4116\n     * This function is copied from https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n     */\n    function checkSuccess() internal pure returns (bool) {\n\t\tuint256 returnValue = 0;\n\n\t\tassembly {\n\t\t\t// check number of bytes returned from last function call\n\t\t\tswitch returndatasize()\n\n\t\t\t// no bytes returned: assume success\n\t\t\tcase 0x0 {\n\t\t\t\treturnValue := 1\n\t\t\t}\n\n\t\t\t// 32 bytes returned: check if non-zero\n\t\t\tcase 0x20 {\n\t\t\t\t// copy 32 bytes into scratch space\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n\n\t\t\t\t// load those bytes into returnValue\n\t\t\t\treturnValue := mload(0x0)\n\t\t\t}\n\n\t\t\t// not sure what was returned: don't mark as success\n\t\t\tdefault { }\n\t\t}\n\t\treturn returnValue != 0;\n\t}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/testingVault.sol": {
      "content": "// this is a contract used for local testing. It is not for live deployment.\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\nimport \"./vault.sol\";\nimport {ERC20 as OZERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"hardhat/console.sol\";\n\ncontract TestingVault {\n    using SafeMath for uint;\n    /**\n     * @dev Storage slot with the incognito proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.incognito.\" subtracted by 1\n     */\n    bytes32 private constant _INCOGNITO_SLOT = 0x62135fc083646fdb4e1a9d700e351b886a4a5a39da980650269edd1ade91ffd2;\n    address constant public ETH_TOKEN = 0x0000000000000000000000000000000000000000;\n\n    /**\n     * @dev Storage variables for Vault\n     * This section is APPEND-ONLY, in order to preserve upgradeability\n     * since we use Proxy Pattern\n     */\n    mapping(bytes32 => bool) public withdrawed;\n    mapping(bytes32 => bool) public sigDataUsed;\n    // address => token => amount\n    mapping(address => mapping(address => uint)) public withdrawRequests;\n    mapping(address => mapping(address => bool)) public migration;\n    mapping(address => uint) public totalDepositedToSCAmount;\n    Withdrawable public prevVault;\n    bool public notEntered = true;\n    bool public isInitialized = false;\n\n    /**\n    * @dev END Storage variables\n    */\n    bool public allowWithdraw = true;\n\n    struct BurnInstData {\n        uint8 meta; // type of the instruction\n        uint8 shard; // ID of the Incognito shard containing the instruction, must be 1\n        address token; // ETH address of the token contract (0x0 for ETH)\n        address payable to; // ETH address of the receiver of the token\n        uint amount; // burned amount (on Incognito)\n        bytes32 itx; // Incognito's burning tx\n    }\n\n    enum Prefix {\n        EXECUTE_SIGNATURE,\n        REQUEST_WITHDRAW_SIGNATURE\n    }\n\n    // error code\n    enum Errors {\n        EMPTY,\n        NO_REENTRANCE,\n        MAX_UINT_REACHED,\n        VALUE_OVER_FLOW,\n        INTERNAL_TX_ERROR,\n        ALREADY_USED,\n        INVALID_DATA,\n        TOKEN_NOT_ENOUGH,\n        WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH,\n        INVALID_RETURN_DATA,\n        NOT_EQUAL,\n        NULL_VALUE,\n        ONLY_PREVAULT,\n        PREVAULT_NOT_PAUSED,\n        SAFEMATH_EXCEPTION,\n        ALREADY_INITIALIZED,\n        INVALID_SIGNATURE\n    }\n\n    event Deposit(address token, string incognitoAddress, uint amount);\n    event Withdraw(address token, address to, uint amount);\n    event UpdateTokenTotal(address[] assets, uint[] amounts);\n    event UpdateIncognitoProxy(address newIncognitoProxy);\n\n    /**\n     * modifier for contract version\n     */\n     modifier onlyPreVault(){\n        require(address(prevVault) != address(0x0) && msg.sender == address(prevVault), errorToString(Errors.ONLY_PREVAULT));\n        _;\n     }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, notEntered will be true\n        require(notEntered, errorToString(Errors.NO_REENTRANCE));\n\n        // Any calls to nonReentrant after this point will fail\n        notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        notEntered = true;\n    }\n\n    function setAllowWithdraw(bool b) public {\n        allowWithdraw = b;\n    }\n\n    /**\n     * @dev Creates new Vault to hold assets for Incognito Chain\n     * @param _prevVault: previous version of the Vault to refer back if necessary\n     * After migrating all assets to a new Vault, we still need to refer\n     * back to previous Vault to make sure old withdrawals aren't being reused\n     */\n    function initialize(address _prevVault) external {\n        require(!isInitialized, errorToString(Errors.ALREADY_INITIALIZED));\n        prevVault = Withdrawable(_prevVault);\n        isInitialized = true;\n        notEntered = true;\n    }\n\n    /**\n     * @dev Returns the current incognito proxy.\n     */\n    function _incognito() internal view returns (address icg) {\n        bytes32 slot = _INCOGNITO_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            icg := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Makes a ETH deposit to the vault to mint pETH over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @param incognitoAddress: Incognito Address to receive pETH\n     */\n    function deposit(string calldata incognitoAddress) external payable nonReentrant {\n        require(address(this).balance <= 10 ** 27, errorToString(Errors.MAX_UINT_REACHED));\n        emit Deposit(ETH_TOKEN, incognitoAddress, msg.value);\n    }\n\n    /**\n     * @dev Makes a ERC20 deposit to the vault to mint pERC20 over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @notice Before calling this function, enough ERC20 must be allowed to\n     * tranfer from msg.sender to this contract\n     * @param token: address of the ERC20 token\n     * @param amount: to deposit to the vault and mint on Incognito Chain\n     * @param incognitoAddress: Incognito Address to receive pERC20\n     */\n    function depositERC20(address token, uint amount, string calldata incognitoAddress) external nonReentrant {\n        IERC20 erc20Interface = IERC20(token);\n        uint8 decimals = getDecimals(address(token));\n        uint tokenBalance = erc20Interface.balanceOf(address(this));\n        uint beforeTransfer = tokenBalance;\n        uint emitAmount = amount;\n        if (decimals > 9) {\n            emitAmount = emitAmount / (10 ** (uint(decimals) - 9));\n            tokenBalance = tokenBalance / (10 ** (uint(decimals) - 9));\n        }\n        require(emitAmount <= 10 ** 18 && tokenBalance <= 10 ** 18 && emitAmount.safeAdd(tokenBalance) <= 10 ** 18, errorToString(Errors.VALUE_OVER_FLOW));\n        erc20Interface.transferFrom(msg.sender, address(this), amount);\n        require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        require(balanceOf(token).safeSub(beforeTransfer) == amount, errorToString(Errors.NOT_EQUAL));\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev Checks if a burn proof has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the burn proof\n     * @return bool: whether the proof has been used or not\n     */\n    function isWithdrawed(bytes32 hash) public view returns(bool) {\n        if (withdrawed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isWithdrawed(hash);\n    }\n\n    /**\n     * @dev Parses a burn instruction and returns the components\n     * @param inst: the full instruction, containing both metadata and body\n     */\n    function parseBurnInst(bytes memory inst) public pure returns (BurnInstData memory) {\n        BurnInstData memory data;\n        data.meta = uint8(inst[0]);\n        data.shard = uint8(inst[1]);\n        address token;\n        address payable to;\n        uint amount;\n        bytes32 itx;\n        assembly {\n            // skip first 0x20 bytes (stored length of inst)\n            token := mload(add(inst, 0x22)) // [3:34]\n            to := mload(add(inst, 0x42)) // [34:66]\n            amount := mload(add(inst, 0x62)) // [66:98]\n            itx := mload(add(inst, 0x82)) // [98:130]\n        }\n        data.token = token;\n        data.to = to;\n        data.amount = amount;\n        data.itx = itx;\n        return data;\n    }\n\n    /**\n     * @dev Verifies that a burn instruction is valid\n     * @notice All params except inst are the list of 2 elements corresponding to\n     * the proof on beacon and bridge\n     * @notice All params are the same as in `withdraw`\n     */\n    function verifyInst(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) view internal {\n        // Each instruction can only by redeemed once\n        bytes32 beaconInstHash = keccak256(abi.encodePacked(inst, heights));\n\n        // Verify instruction on beacon\n        require(Incognito(_incognito()).instructionApproved(\n            true, // Only check instruction on beacon\n            beaconInstHash,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        ), errorToString(Errors.INVALID_DATA));\n    }\n\n    /**\n     * @dev Withdraws pETH/pIERC20 by providing a burn proof over at Incognito Chain\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function withdraw(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130, errorToString(Errors.INVALID_DATA));\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 241 && data.shard == 1, errorToString(Errors.INVALID_DATA)); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                data.amount = data.amount.safeMul(10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        // Send and notify\n        if (allowWithdraw) {\n            if (data.token == ETH_TOKEN) {\n              (bool success, ) =  data.to.call{value: data.amount}(\"\");\n              require(success, errorToString(Errors.INTERNAL_TX_ERROR));\n            } else {\n                IERC20(data.token).transfer(data.to, data.amount);\n                require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n            }\n            emit Withdraw(data.token, data.to, data.amount);\n        } else {\n            // simulate the effect of an attack; here user will lose pToken without receiving anything on Ethereum\n            // we use this to test pausing & upgrading features\n            console.log(\"cannot withdraw\");\n        }\n    }\n\n    /**\n     * @dev Burnt Proof is submited to store burnt amount of p-token/p-ETH and receiver's address\n     * Receiver then can call withdrawRequest to withdraw these token to he/she incognito address.\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function submitBurnProof(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130, errorToString(Errors.INVALID_DATA));\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 243 && data.shard == 1, errorToString(Errors.INVALID_DATA)); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                data.amount = data.amount.safeMul(10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        withdrawRequests[data.to][data.token] = withdrawRequests[data.to][data.token].safeAdd(data.amount);\n        totalDepositedToSCAmount[data.token] = totalDepositedToSCAmount[data.token].safeAdd(data.amount);\n    }\n\n    /**\n     * @dev generate address from signature data and hash.\n     */\n    function sigToAddress(bytes memory signData, bytes32 hash) public pure returns (address) {\n        bytes32 s;\n        bytes32 r;\n        uint8 v;\n        assembly {\n            r := mload(add(signData, 0x20))\n            s := mload(add(signData, 0x40))\n        }\n        v = uint8(signData[64]) + 27;\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Checks if a sig data has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the sig data\n     * @return bool: whether the sig data has been used or not\n     */\n    function isSigDataUsed(bytes32 hash) public view returns(bool) {\n        if (sigDataUsed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isSigDataUsed(hash);\n    }\n\n    struct PreSignData {\n        Prefix prefix;\n        address token;\n        bytes timestamp;\n        uint amount;\n    }\n\n    function newPreSignData(Prefix prefix, address token, bytes calldata timestamp, uint amount) pure internal returns (PreSignData memory) {\n        PreSignData memory psd = PreSignData(prefix, token, timestamp, amount);\n        return psd;\n    }\n\n    /**\n     * @dev User requests withdraw token contains in withdrawRequests.\n     * Deposit event will be emitted to let incognito recognize and mint new p-tokens for the user.\n     * @param incognitoAddress: incognito's address that will receive minted p-tokens.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     * @param timestamp: unique data generated from client (timestamp for example)\n     */\n    function requestWithdraw(\n        string calldata incognitoAddress,\n        address token,\n        uint amount,\n        bytes calldata signData,\n        bytes calldata timestamp\n    ) external nonReentrant {\n        // verify owner signs data\n        address verifier = verifySignData(abi.encode(newPreSignData(Prefix.REQUEST_WITHDRAW_SIGNATURE, token, timestamp, amount), incognitoAddress), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n\n        // convert denomination from ethereum's to incognito's (pcoin)\n        uint emitAmount = amount;\n        if (token != ETH_TOKEN) {\n            uint8 decimals = getDecimals(token);\n            if (decimals > 9) {\n                emitAmount = amount / (10 ** (uint(decimals) - 9));\n            }\n        }\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev execute is a general function that plays a role as proxy to interact to other smart contracts.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param recipientToken: received token address.\n     * @param exchangeAddress: address of targeting smart contract that actually executes the desired logics like trade, invest, borrow and so on.\n     * @param callData: encoded with signature and params of function from targeting smart contract.\n     * @param timestamp: unique data generated from client (timestamp for example)\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     */\n    function execute(\n        address token,\n        uint amount,\n        address recipientToken,\n        address exchangeAddress,\n        bytes calldata callData,\n        bytes calldata timestamp,\n        bytes calldata signData\n    ) external payable nonReentrant {\n        //verify ower signs data from input\n        address verifier = verifySignData(abi.encode(newPreSignData(Prefix.EXECUTE_SIGNATURE, token, timestamp, amount), recipientToken, exchangeAddress, callData), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n\n        // update balance of verifier\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n\n        // define number of eth spent for forwarder.\n        uint ethAmount = msg.value;\n        if (token == ETH_TOKEN) {\n            ethAmount = ethAmount.safeAdd(amount);\n        } else {\n            // transfer token to exchangeAddress.\n            require(IERC20(token).balanceOf(address(this)) >= amount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n            IERC20(token).transfer(exchangeAddress, amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        uint returnedAmount = callExtFunc(recipientToken, ethAmount, callData, exchangeAddress);\n\n        // update withdrawRequests\n        withdrawRequests[verifier][recipientToken] = withdrawRequests[verifier][recipientToken].safeAdd(returnedAmount);\n        totalDepositedToSCAmount[recipientToken] = totalDepositedToSCAmount[recipientToken].safeAdd(returnedAmount);\n    }\n\n    /**\n     * @dev single trade\n     */\n    function callExtFunc(address recipientToken, uint ethAmount, bytes memory callData, address exchangeAddress) internal returns (uint) {\n         // get balance of recipient token before trade to compare after trade.\n        uint balanceBeforeTrade = balanceOf(recipientToken);\n        if (recipientToken == ETH_TOKEN) {\n            balanceBeforeTrade = balanceBeforeTrade.safeSub(msg.value);\n        }\n        require(address(this).balance >= ethAmount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n        (bool success, bytes memory result) = exchangeAddress.call{value: ethAmount}(callData);\n        require(success, errorToString(Errors.INTERNAL_TX_ERROR));\n\n        (address returnedTokenAddress, uint returnedAmount) = abi.decode(result, (address, uint));\n        require(returnedTokenAddress == recipientToken && balanceOf(recipientToken).safeSub(balanceBeforeTrade) == returnedAmount, errorToString(Errors.INVALID_RETURN_DATA));\n\n        return returnedAmount;\n    }\n\n    /**\n     * @dev verify sign data\n     */\n     function verifySignData(bytes memory data, bytes memory signData) internal returns(address){\n        bytes32 hash = keccak256(data);\n        require(!isSigDataUsed(hash), errorToString(Errors.ALREADY_USED));\n        address verifier = sigToAddress(signData, hash);\n        // reject when verifier equals zero\n        require(verifier != address(0x0), errorToString(Errors.INVALID_SIGNATURE));\n        // mark data hash of sig as used\n        sigDataUsed[hash] = true;\n\n        return verifier;\n     }\n\n    /**\n      * @dev migrate balance from previous vault\n      * Note: uncomment for next version\n      */\n    function migrateBalance(address owner, address token) internal {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n            withdrawRequests[owner][token] = withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n            migration[owner][token] = true;\n       }\n    }\n\n    /**\n     * @dev Get the amount of specific coin for specific wallet\n     */\n    function getDepositedBalance(\n        address token,\n        address owner\n    ) public view returns (uint) {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n            return withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n        }\n        return withdrawRequests[owner][token];\n    }\n\n    /**\n     * @dev Move total number of assets to newVault\n     * @notice This only works when the preVault is Paused\n     * @notice This can only be called by preVault\n     * @param assets: address of the ERC20 tokens to move, 0x0 for ETH\n     * @param amounts: total number of the ERC20 tokens to move, 0x0 for ETH\n     */\n    function updateAssets(address[] calldata assets, uint[] calldata amounts) external onlyPreVault returns(bool) {\n        require(assets.length == amounts.length,  errorToString(Errors.NOT_EQUAL));\n        require(Withdrawable(prevVault).paused(), errorToString(Errors.PREVAULT_NOT_PAUSED));\n        for (uint i = 0; i < assets.length; i++) {\n            totalDepositedToSCAmount[assets[i]] = totalDepositedToSCAmount[assets[i]].safeAdd(amounts[i]);\n        }\n        emit UpdateTokenTotal(assets, amounts);\n\n        return true;\n    }\n\n    /**\n     * @dev Payable receive function to receive Ether from oldVault when migrating\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Check if transfer() and transferFrom() of ERC20 succeeded or not\n     * This check is needed to fix https://github.com/ethereum/solidity/issues/4116\n     * This function is copied from https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n     */\n    function checkSuccess() private pure returns (bool) {\n        uint256 returnValue = 0;\n        assembly {\n            // check number of bytes returned from last function call\n            switch returndatasize()\n\n            // no bytes returned: assume success\n            case 0x0 {\n                returnValue := 1\n            }\n\n            // 32 bytes returned: check if non-zero\n            case 0x20 {\n                // copy 32 bytes into scratch space\n                returndatacopy(0x0, 0x0, 0x20)\n\n                // load those bytes into returnValue\n                returnValue := mload(0x0)\n            }\n\n            // not sure what was returned: don't mark as success\n            default { }\n        }\n        return returnValue != 0;\n    }\n\n    /**\n     * @dev convert enum to string value\n     */\n     function errorToString(Errors error) internal pure returns(string memory) {\n        uint8 erroNum = uint8(error);\n        uint maxlength = 10;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (erroNum != 0) {\n            uint8 remainder = erroNum % 10;\n            erroNum = erroNum / 10;\n            reversed[i++] = byte(48 + remainder);\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j <= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        return string(s);\n    }\n\n    /**\n     * @dev Get the decimals of an ERC20 token, return 0 if it isn't defined\n     * We check the returndatasize to covert both cases that the token has\n     * and doesn't have the function decimals()\n     */\n    function getDecimals(address token) public view returns (uint8) {\n        IERC20 erc20 = IERC20(token);\n        return uint8(erc20.decimals());\n    }\n\n    /**\n     * @dev Get the amount of coin deposited to this smartcontract\n     */\n    function balanceOf(address token) public view returns (uint) {\n        if (token == ETH_TOKEN) {\n            return address(this).balance;\n        }\n        return IERC20(token).balanceOf(address(this));\n    }\n}\n\n\n\ncontract Token1 is OZERC20 {\n    constructor () OZERC20(\"Test Token 1\", \"TT1\") public {}\n    function mint(address account, uint256 amount) public payable {\n        _mint(account, amount);\n    }\n}\ncontract Token2 is OZERC20 {\n    constructor () OZERC20(\"Test Token 2\", \"TT2\") public {\n        _setupDecimals(8);\n    }\n    function mint(address account, uint256 amount) public payable {\n        _mint(account, amount);\n    }\n}\ncontract Token3 is OZERC20 {\n    constructor () OZERC20(\"Test Token 3\", \"TT3\") public {\n        _setupDecimals(16);\n    }\n    function mint(address account, uint256 amount) public payable {\n        _mint(account, amount);\n    }\n}\n\ncontract TestingExchange {\n    // swap 1-1 for everything\n    constructor() public {}\n    receive() external payable {}\n    // kyber interface\n    // trade() will not be called\n    function trade(IERC20 src, uint srcAmount, IERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId) external payable returns(uint) {\n        dest.transfer(destAddress, srcAmount);\n        return srcAmount;\n    }\n    function swapTokenToToken(IERC20 src, uint srcAmount, IERC20 dest, uint minConversionRate) external returns(uint) {\n        src.transferFrom(msg.sender, address(this), srcAmount);\n        dest.transfer(msg.sender, srcAmount);\n        return srcAmount;\n    }\n    function swapEtherToToken(IERC20 token, uint minConversionRate) external payable returns(uint) {\n        uint val = msg.value;\n        // msg.sender.transfer(val);\n        token.transfer(msg.sender, val);\n        return val;\n    }\n    function swapTokenToEther(IERC20 token, uint srcAmount, uint minConversionRate) external returns(uint) {\n        token.transferFrom(msg.sender, address(this), srcAmount);\n        msg.sender.transfer(srcAmount);\n        return srcAmount;\n    }\n    function getExpectedRate(IERC20 src, IERC20 dest, uint srcQty) external view returns(uint expectedRate, uint slippageRate) {\n        return (1000000000000000000, 1000000000000000000);\n    }\n\n    // uniswap interface\n    function factory() external pure returns (address) { return address(0x0); }\n    function WETH() external pure returns (address) { return address(0x0); }\n\n    // path length of 2 only\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        uint len = path.length;\n        uint[] memory result = new uint[](len);\n        result[len-1] = amountOutMin;\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n        IERC20(path[len-1]).transfer(msg.sender, amountOutMin);\n        return result;\n    }\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts) {\n        uint len = path.length;\n        uint[] memory result = new uint[](len);\n        result[len-1] = amountOutMin;\n        IERC20(path[len-1]).transfer(msg.sender, amountOutMin);\n        return result;\n    }\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts) {\n        uint len = path.length;\n        uint[] memory result = new uint[](len);\n        result[len-1] = amountOutMin;\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n        msg.sender.transfer(amountOutMin);\n        return result;\n    }\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts) {\n        uint[] memory result = new uint[](2);\n        result[0] = amountIn;\n        result[1] = amountIn;\n        return result;\n    }\n}"
    },
    "contracts/vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\n\n/**\n * Math operations with safety checks\n */\nlibrary SafeMath {\n  string private constant ERROR_MESSAGE = \"SafeMath exception\";\n  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b, ERROR_MESSAGE);\n    return c;\n  }\n\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, ERROR_MESSAGE);\n    uint256 c = a / b;\n    require(a == b * c + a % b, ERROR_MESSAGE);\n    return c;\n  }\n\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, ERROR_MESSAGE);\n    return a - b;\n  }\n\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c>=a && c>=b, ERROR_MESSAGE);\n    return c;\n  }\n}\n\n\n/**\n * @dev Interface of the contract capable of checking if an instruction is\n * confirmed over at Incognito Chain\n */\ninterface Incognito {\n    function instructionApproved(\n        bool,\n        bytes32,\n        uint,\n        bytes32[] calldata,\n        bool[] calldata,\n        bytes32,\n        bytes32,\n        uint[] calldata,\n        uint8[] calldata,\n        bytes32[] calldata,\n        bytes32[] calldata\n    ) external view returns (bool);\n}\n\n/**\n * @dev Interface of the previous Vault contract to query burn proof status\n */\ninterface Withdrawable {\n    function isWithdrawed(bytes32)  external view returns (bool);\n    function isSigDataUsed(bytes32)  external view returns (bool);\n    function getDepositedBalance(address, address)  external view returns (uint);\n    function updateAssets(address[] calldata, uint[] calldata) external returns (bool);\n    function paused() external view returns (bool);\n}\n\n/**\n * @dev Responsible for holding the assets and issue minting instruction to\n * Incognito Chain. Also, when presented with a burn proof created over at\n * Incognito Chain, releases the tokens back to user\n */\ncontract Vault {\n    using SafeMath for uint;\n    /**\n     * @dev Storage slot with the incognito proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.incognito.\" subtracted by 1\n     */\n    bytes32 private constant _INCOGNITO_SLOT = 0x62135fc083646fdb4e1a9d700e351b886a4a5a39da980650269edd1ade91ffd2;\n    address constant public ETH_TOKEN = 0x0000000000000000000000000000000000000000;\n\n    /**\n     * @dev Storage variables for Vault\n     * This section is APPEND-ONLY, in order to preserve upgradeability\n     * since we use Proxy Pattern\n     */\n    mapping(bytes32 => bool) public withdrawed;\n    mapping(bytes32 => bool) public sigDataUsed;\n    // address => token => amount\n    mapping(address => mapping(address => uint)) public withdrawRequests;\n    mapping(address => mapping(address => bool)) public migration;\n    mapping(address => uint) public totalDepositedToSCAmount;\n    Withdrawable public prevVault;\n    bool public notEntered = true;\n    bool public isInitialized = false;\n\n    /**\n    * @dev END Storage variables\n    */\n\n    struct BurnInstData {\n        uint8 meta; // type of the instruction\n        uint8 shard; // ID of the Incognito shard containing the instruction, must be 1\n        address token; // ETH address of the token contract (0x0 for ETH)\n        address payable to; // ETH address of the receiver of the token\n        uint amount; // burned amount (on Incognito)\n        bytes32 itx; // Incognito's burning tx\n    }\n\n    enum Prefix {\n        EXECUTE_SIGNATURE,\n        REQUEST_WITHDRAW_SIGNATURE\n    }\n\n    // error code\n    enum Errors {\n        EMPTY,\n        NO_REENTRANCE,\n        MAX_UINT_REACHED,\n        VALUE_OVER_FLOW,\n        INTERNAL_TX_ERROR,\n        ALREADY_USED,\n        INVALID_DATA,\n        TOKEN_NOT_ENOUGH,\n        WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH,\n        INVALID_RETURN_DATA,\n        NOT_EQUAL,\n        NULL_VALUE,\n        ONLY_PREVAULT,\n        PREVAULT_NOT_PAUSED,\n        SAFEMATH_EXCEPTION,\n        ALREADY_INITIALIZED,\n        INVALID_SIGNATURE\n    }\n\n    event Deposit(address token, string incognitoAddress, uint amount);\n    event Withdraw(address token, address to, uint amount);\n    event UpdateTokenTotal(address[] assets, uint[] amounts);\n    event UpdateIncognitoProxy(address newIncognitoProxy);\n\n    /**\n     * modifier for contract version\n     */\n     modifier onlyPreVault(){\n        require(address(prevVault) != address(0x0) && msg.sender == address(prevVault), errorToString(Errors.ONLY_PREVAULT));\n        _;\n     }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, notEntered will be true\n        require(notEntered, errorToString(Errors.NO_REENTRANCE));\n\n        // Any calls to nonReentrant after this point will fail\n        notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        notEntered = true;\n    }\n\n    /**\n     * @dev Creates new Vault to hold assets for Incognito Chain\n     * @param _prevVault: previous version of the Vault to refer back if necessary\n     * After migrating all assets to a new Vault, we still need to refer\n     * back to previous Vault to make sure old withdrawals aren't being reused\n     */\n    function initialize(address _prevVault) external {\n        require(!isInitialized, errorToString(Errors.ALREADY_INITIALIZED));\n        prevVault = Withdrawable(_prevVault);\n        isInitialized = true;\n        notEntered = true;\n    }\n\n    /**\n     * @dev Returns the current incognito proxy.\n     */\n    function _incognito() internal view returns (address icg) {\n        bytes32 slot = _INCOGNITO_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            icg := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Makes a ETH deposit to the vault to mint pETH over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @param incognitoAddress: Incognito Address to receive pETH\n     */\n    function deposit(string calldata incognitoAddress) external payable nonReentrant {\n        require(address(this).balance <= 10 ** 27, errorToString(Errors.MAX_UINT_REACHED));\n        emit Deposit(ETH_TOKEN, incognitoAddress, msg.value);\n    }\n\n    /**\n     * @dev Makes a ERC20 deposit to the vault to mint pERC20 over at Incognito Chain\n     * @notice This only works when the contract is not Paused\n     * @notice The maximum amount to deposit is capped since Incognito balance is stored as uint64\n     * @notice Before calling this function, enough ERC20 must be allowed to\n     * tranfer from msg.sender to this contract\n     * @param token: address of the ERC20 token\n     * @param amount: to deposit to the vault and mint on Incognito Chain\n     * @param incognitoAddress: Incognito Address to receive pERC20\n     */\n    function depositERC20(address token, uint amount, string calldata incognitoAddress) external nonReentrant {\n        IERC20 erc20Interface = IERC20(token);\n        uint8 decimals = getDecimals(address(token));\n        uint tokenBalance = erc20Interface.balanceOf(address(this));\n        uint beforeTransfer = tokenBalance;\n        uint emitAmount = amount;\n        if (decimals > 9) {\n            emitAmount = emitAmount / (10 ** (uint(decimals) - 9));\n            tokenBalance = tokenBalance / (10 ** (uint(decimals) - 9));\n        }\n        require(emitAmount <= 10 ** 18 && tokenBalance <= 10 ** 18 && emitAmount.safeAdd(tokenBalance) <= 10 ** 18, errorToString(Errors.VALUE_OVER_FLOW));\n        erc20Interface.transferFrom(msg.sender, address(this), amount);\n        require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        require(balanceOf(token).safeSub(beforeTransfer) == amount, errorToString(Errors.NOT_EQUAL));\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev Checks if a burn proof has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the burn proof\n     * @return bool: whether the proof has been used or not\n     */\n    function isWithdrawed(bytes32 hash) public view returns(bool) {\n        if (withdrawed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isWithdrawed(hash);\n    }\n\n    /**\n     * @dev Parses a burn instruction and returns the components\n     * @param inst: the full instruction, containing both metadata and body\n     */\n    function parseBurnInst(bytes memory inst) public pure returns (BurnInstData memory) {\n        BurnInstData memory data;\n        data.meta = uint8(inst[0]);\n        data.shard = uint8(inst[1]);\n        address token;\n        address payable to;\n        uint amount;\n        bytes32 itx;\n        assembly {\n            // skip first 0x20 bytes (stored length of inst)\n            token := mload(add(inst, 0x22)) // [3:34]\n            to := mload(add(inst, 0x42)) // [34:66]\n            amount := mload(add(inst, 0x62)) // [66:98]\n            itx := mload(add(inst, 0x82)) // [98:130]\n        }\n        data.token = token;\n        data.to = to;\n        data.amount = amount;\n        data.itx = itx;\n        return data;\n    }\n\n    /**\n     * @dev Verifies that a burn instruction is valid\n     * @notice All params except inst are the list of 2 elements corresponding to\n     * the proof on beacon and bridge\n     * @notice All params are the same as in `withdraw`\n     */\n    function verifyInst(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) view internal {\n        // Each instruction can only by redeemed once\n        bytes32 beaconInstHash = keccak256(abi.encodePacked(inst, heights));\n\n        // Verify instruction on beacon\n        require(Incognito(_incognito()).instructionApproved(\n            true, // Only check instruction on beacon\n            beaconInstHash,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        ), errorToString(Errors.INVALID_DATA));\n    }\n\n    /**\n     * @dev Withdraws pETH/pIERC20 by providing a burn proof over at Incognito Chain\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function withdraw(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130, errorToString(Errors.INVALID_DATA));\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 241 && data.shard == 1, errorToString(Errors.INVALID_DATA)); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                data.amount = data.amount.safeMul(10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        // Send and notify\n        if (data.token == ETH_TOKEN) {\n          (bool success, ) =  data.to.call{value: data.amount}(\"\");\n          require(success, errorToString(Errors.INTERNAL_TX_ERROR));\n        } else {\n            IERC20(data.token).transfer(data.to, data.amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        emit Withdraw(data.token, data.to, data.amount);\n    }\n\n    /**\n     * @dev Burnt Proof is submited to store burnt amount of p-token/p-ETH and receiver's address\n     * Receiver then can call withdrawRequest to withdraw these token to he/she incognito address.\n     * @notice This function takes a burn instruction on Incognito Chain, checks\n     * for its validity and returns the token back to ETH chain\n     * @notice This only works when the contract is not Paused\n     * @param inst: the decoded instruction as a list of bytes\n     * @param heights: the blocks containing the instruction\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function submitBurnProof(\n        bytes memory inst,\n        uint heights,\n        bytes32[] memory instPaths,\n        bool[] memory instPathIsLefts,\n        bytes32 instRoots,\n        bytes32 blkData,\n        uint[] memory sigIdxs,\n        uint8[] memory sigVs,\n        bytes32[] memory sigRs,\n        bytes32[] memory sigSs\n    ) public nonReentrant {\n        require(inst.length >= 130, errorToString(Errors.INVALID_DATA));\n        BurnInstData memory data = parseBurnInst(inst);\n        require(data.meta == 243 && data.shard == 1, errorToString(Errors.INVALID_DATA)); // Check instruction type\n\n        // Not withdrawed\n        require(!isWithdrawed(data.itx), errorToString(Errors.ALREADY_USED));\n        withdrawed[data.itx] = true;\n\n        // Check if balance is enough\n        if (data.token == ETH_TOKEN) {\n            require(address(this).balance >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        } else {\n            uint8 decimals = getDecimals(data.token);\n            if (decimals > 9) {\n                data.amount = data.amount.safeMul(10 ** (uint(decimals) - 9));\n            }\n            require(IERC20(data.token).balanceOf(address(this)) >= data.amount.safeAdd(totalDepositedToSCAmount[data.token]), errorToString(Errors.TOKEN_NOT_ENOUGH));\n        }\n\n        verifyInst(\n            inst,\n            heights,\n            instPaths,\n            instPathIsLefts,\n            instRoots,\n            blkData,\n            sigIdxs,\n            sigVs,\n            sigRs,\n            sigSs\n        );\n\n        withdrawRequests[data.to][data.token] = withdrawRequests[data.to][data.token].safeAdd(data.amount);\n        totalDepositedToSCAmount[data.token] = totalDepositedToSCAmount[data.token].safeAdd(data.amount);\n    }\n\n    /**\n     * @dev generate address from signature data and hash.\n     */\n    function sigToAddress(bytes memory signData, bytes32 hash) public pure returns (address) {\n        bytes32 s;\n        bytes32 r;\n        uint8 v;\n        assembly {\n            r := mload(add(signData, 0x20))\n            s := mload(add(signData, 0x40))\n        }\n        v = uint8(signData[64]) + 27;\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Checks if a sig data has been used before\n     * @notice First, we check inside the storage of this contract itself. If the\n     * hash has been used before, we return the result. Otherwise, we query\n     * previous vault recursively until the first Vault (prevVault address is 0x0)\n     * @param hash: of the sig data\n     * @return bool: whether the sig data has been used or not\n     */\n    function isSigDataUsed(bytes32 hash) public view returns(bool) {\n        if (sigDataUsed[hash]) {\n            return true;\n        } else if (address(prevVault) == address(0)) {\n            return false;\n        }\n        return prevVault.isSigDataUsed(hash);\n    }\n\n    struct PreSignData {\n        Prefix prefix;\n        address token;\n        bytes timestamp;\n        uint amount;\n    }\n\n    function newPreSignData(Prefix prefix, address token, bytes calldata timestamp, uint amount) pure internal returns (PreSignData memory) {\n        PreSignData memory psd = PreSignData(prefix, token, timestamp, amount);\n        return psd;\n    }\n\n    /**\n     * @dev User requests withdraw token contains in withdrawRequests.\n     * Deposit event will be emitted to let incognito recognize and mint new p-tokens for the user.\n     * @param incognitoAddress: incognito's address that will receive minted p-tokens.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     * @param timestamp: unique data generated from client (timestamp for example)\n     */\n    function requestWithdraw(\n        string calldata incognitoAddress,\n        address token,\n        uint amount,\n        bytes calldata signData,\n        bytes calldata timestamp\n    ) external nonReentrant {\n        // verify owner signs data\n        address verifier = verifySignData(abi.encode(newPreSignData(Prefix.REQUEST_WITHDRAW_SIGNATURE, token, timestamp, amount), incognitoAddress), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n\n        // convert denomination from ethereum's to incognito's (pcoin)\n        uint emitAmount = amount;\n        if (token != ETH_TOKEN) {\n            uint8 decimals = getDecimals(token);\n            if (decimals > 9) {\n                emitAmount = amount / (10 ** (uint(decimals) - 9));\n            }\n        }\n\n        emit Deposit(token, incognitoAddress, emitAmount);\n    }\n\n    /**\n     * @dev execute is a general function that plays a role as proxy to interact to other smart contracts.\n     * @param token: ethereum's token address (eg., ETH, DAI, ...)\n     * @param amount: amount of the token in ethereum's denomination\n     * @param recipientToken: received token address.\n     * @param exchangeAddress: address of targeting smart contract that actually executes the desired logics like trade, invest, borrow and so on.\n     * @param callData: encoded with signature and params of function from targeting smart contract.\n     * @param timestamp: unique data generated from client (timestamp for example)\n     * @param signData: signature of an unique data that is signed by an account which is generated from user's incognito privkey\n     */\n    function execute(\n        address token,\n        uint amount,\n        address recipientToken,\n        address exchangeAddress,\n        bytes calldata callData,\n        bytes calldata timestamp,\n        bytes calldata signData\n    ) external payable nonReentrant {\n        //verify ower signs data from input\n        address verifier = verifySignData(abi.encode(newPreSignData(Prefix.EXECUTE_SIGNATURE, token, timestamp, amount), recipientToken, exchangeAddress, callData), signData);\n\n        // migrate from preVault\n        migrateBalance(verifier, token);\n        require(withdrawRequests[verifier][token] >= amount, errorToString(Errors.WITHDRAW_REQUEST_TOKEN_NOT_ENOUGH));\n\n        // update balance of verifier\n        totalDepositedToSCAmount[token] = totalDepositedToSCAmount[token].safeSub(amount);\n        withdrawRequests[verifier][token] = withdrawRequests[verifier][token].safeSub(amount);\n\n        // define number of eth spent for forwarder.\n        uint ethAmount = msg.value;\n        if (token == ETH_TOKEN) {\n            ethAmount = ethAmount.safeAdd(amount);\n        } else {\n            // transfer token to exchangeAddress.\n            require(IERC20(token).balanceOf(address(this)) >= amount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n            IERC20(token).transfer(exchangeAddress, amount);\n            require(checkSuccess(), errorToString(Errors.INTERNAL_TX_ERROR));\n        }\n        uint returnedAmount = callExtFunc(recipientToken, ethAmount, callData, exchangeAddress);\n\n        // update withdrawRequests\n        withdrawRequests[verifier][recipientToken] = withdrawRequests[verifier][recipientToken].safeAdd(returnedAmount);\n        totalDepositedToSCAmount[recipientToken] = totalDepositedToSCAmount[recipientToken].safeAdd(returnedAmount);\n    }\n\n    /**\n     * @dev single trade\n     */\n    function callExtFunc(address recipientToken, uint ethAmount, bytes memory callData, address exchangeAddress) internal returns (uint) {\n         // get balance of recipient token before trade to compare after trade.\n        uint balanceBeforeTrade = balanceOf(recipientToken);\n        if (recipientToken == ETH_TOKEN) {\n            balanceBeforeTrade = balanceBeforeTrade.safeSub(msg.value);\n        }\n        require(address(this).balance >= ethAmount, errorToString(Errors.TOKEN_NOT_ENOUGH));\n        (bool success, bytes memory result) = exchangeAddress.call{value: ethAmount}(callData);\n        require(success, errorToString(Errors.INTERNAL_TX_ERROR));\n\n        (address returnedTokenAddress, uint returnedAmount) = abi.decode(result, (address, uint));\n        require(returnedTokenAddress == recipientToken && balanceOf(recipientToken).safeSub(balanceBeforeTrade) == returnedAmount, errorToString(Errors.INVALID_RETURN_DATA));\n\n        return returnedAmount;\n    }\n\n    /**\n     * @dev verify sign data\n     */\n     function verifySignData(bytes memory data, bytes memory signData) internal returns(address){\n        bytes32 hash = keccak256(data);\n        require(!isSigDataUsed(hash), errorToString(Errors.ALREADY_USED));\n        address verifier = sigToAddress(signData, hash);\n        // reject when verifier equals zero\n        require(verifier != address(0x0), errorToString(Errors.INVALID_SIGNATURE));\n        // mark data hash of sig as used\n        sigDataUsed[hash] = true;\n\n        return verifier;\n     }\n\n    /**\n      * @dev migrate balance from previous vault\n      * Note: uncomment for next version\n      */\n    function migrateBalance(address owner, address token) internal {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n            withdrawRequests[owner][token] = withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n  \t        migration[owner][token] = true;\n  \t   }\n    }\n\n    /**\n     * @dev Get the amount of specific coin for specific wallet\n     */\n    function getDepositedBalance(\n        address token,\n        address owner\n    ) public view returns (uint) {\n        if (address(prevVault) != address(0x0) && !migration[owner][token]) {\n \t        return withdrawRequests[owner][token].safeAdd(prevVault.getDepositedBalance(token, owner));\n \t    }\n        return withdrawRequests[owner][token];\n    }\n\n    /**\n     * @dev Move total number of assets to newVault\n     * @notice This only works when the preVault is Paused\n     * @notice This can only be called by preVault\n     * @param assets: address of the ERC20 tokens to move, 0x0 for ETH\n     * @param amounts: total number of the ERC20 tokens to move, 0x0 for ETH\n     */\n    function updateAssets(address[] calldata assets, uint[] calldata amounts) external onlyPreVault returns(bool) {\n        require(assets.length == amounts.length,  errorToString(Errors.NOT_EQUAL));\n        require(Withdrawable(prevVault).paused(), errorToString(Errors.PREVAULT_NOT_PAUSED));\n        for (uint i = 0; i < assets.length; i++) {\n            totalDepositedToSCAmount[assets[i]] = totalDepositedToSCAmount[assets[i]].safeAdd(amounts[i]);\n        }\n        emit UpdateTokenTotal(assets, amounts);\n\n        return true;\n    }\n\n    /**\n     * @dev Payable receive function to receive Ether from oldVault when migrating\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Check if transfer() and transferFrom() of ERC20 succeeded or not\n     * This check is needed to fix https://github.com/ethereum/solidity/issues/4116\n     * This function is copied from https://github.com/AdExNetwork/adex-protocol-eth/blob/master/contracts/libs/SafeERC20.sol\n     */\n    function checkSuccess() private pure returns (bool) {\n\t\tuint256 returnValue = 0;\n\t\tassembly {\n\t\t\t// check number of bytes returned from last function call\n\t\t\tswitch returndatasize()\n\n\t\t\t// no bytes returned: assume success\n\t\t\tcase 0x0 {\n\t\t\t\treturnValue := 1\n\t\t\t}\n\n\t\t\t// 32 bytes returned: check if non-zero\n\t\t\tcase 0x20 {\n\t\t\t\t// copy 32 bytes into scratch space\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\n\n\t\t\t\t// load those bytes into returnValue\n\t\t\t\treturnValue := mload(0x0)\n\t\t\t}\n\n\t\t\t// not sure what was returned: don't mark as success\n\t\t\tdefault { }\n\t\t}\n\t\treturn returnValue != 0;\n\t}\n\n    /**\n     * @dev convert enum to string value\n     */\n     function errorToString(Errors error) internal pure returns(string memory) {\n        uint8 erroNum = uint8(error);\n        uint maxlength = 10;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (erroNum != 0) {\n            uint8 remainder = erroNum % 10;\n            erroNum = erroNum / 10;\n            reversed[i++] = byte(48 + remainder);\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j <= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        return string(s);\n    }\n\n    /**\n     * @dev Get the decimals of an ERC20 token, return 0 if it isn't defined\n     * We check the returndatasize to covert both cases that the token has\n     * and doesn't have the function decimals()\n     */\n    function getDecimals(address token) public view returns (uint8) {\n        IERC20 erc20 = IERC20(token);\n        return uint8(erc20.decimals());\n    }\n\n    /**\n     * @dev Get the amount of coin deposited to this smartcontract\n     */\n    function balanceOf(address token) public view returns (uint) {\n        if (token == ETH_TOKEN) {\n            return address(this).balance;\n        }\n        return IERC20(token).balanceOf(address(this));\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/kbn_trade.sol": {
      "content": "pragma solidity ^0.6.12;\n\nimport './trade_utils.sol';\nimport './IERC20.sol';\n\ninterface KyberNetwork {\n    function trade(IERC20 src, uint srcAmount, IERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId) external payable returns(uint);\n    function swapTokenToToken(IERC20 src, uint srcAmount, IERC20 dest, uint minConversionRate) external returns(uint);\n    function swapEtherToToken(IERC20 token, uint minConversionRate) external payable returns(uint);\n    function swapTokenToEther(IERC20 token, uint srcAmount, uint minConversionRate) external returns(uint);\n    function getExpectedRate(IERC20 src, IERC20 dest, uint srcQty) external view returns(uint expectedRate, uint slippageRate);\n}\n\ncontract KBNTrade is TradeUtils {\n    // Variables\n    KyberNetwork public kyberNetworkProxyContract;\n    IERC20 constant KYBER_ETH_TOKEN_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    // Functions\n    /**\n     * @dev Contract constructor\n     * @param _kyberNetworkProxyContract KyberNetworkProxy contract address\n     */\n    constructor(KyberNetwork _kyberNetworkProxyContract) public {\n        kyberNetworkProxyContract = _kyberNetworkProxyContract;\n    }\n\n    // Reciever function which allows transfer eth.\n    receive() external payable {}\n\n    /**\n     * @dev Gets the conversion rate for the destToken given the srcQty.\n     * @param srcToken source token contract address\n     * @param srcQty amount of source tokens\n     * @param destToken destination token contract address\n     */\n    function getConversionRates(IERC20 srcToken, uint srcQty, IERC20 destToken) public view returns (uint, uint) {\n        return kyberNetworkProxyContract.getExpectedRate(srcToken, destToken, srcQty);\n    }\n\n    function trade(IERC20 srcToken, uint srcQty, IERC20 destToken, uint minConversionRate) public payable returns (address, uint) {\n        require(balanceOf(srcToken) >= srcQty);\n        require(srcToken != destToken);\n        uint amount = 0;\n        if (srcToken != ETH_CONTRACT_ADDRESS) {\n            // approve\n            approve(srcToken, address(kyberNetworkProxyContract), srcQty);\n            if (destToken != ETH_CONTRACT_ADDRESS) { // token to token.\n                require(tokenToToken(srcToken, srcQty, destToken, minConversionRate) > 0);\n            } else {\n                require(tokenToEth(srcToken, srcQty, minConversionRate) > 0);\n            }\n        } else {\n            require(ethToToken(destToken, srcQty, minConversionRate) > 0);\n        }\n        // transfer back to incognito smart contract\n        amount = balanceOf(destToken);\n        transfer(destToken, amount);\n        return (address(destToken), amount);\n    }\n\n    function ethToToken(IERC20 token, uint srcQty, uint minConversionRate) internal returns (uint) {\n        // Get the minimum conversion rate\n        require(address(this).balance >= srcQty);\n        return kyberNetworkProxyContract.swapEtherToToken{value: srcQty}(token, minConversionRate);\n    }\n\n    function tokenToEth(IERC20 token, uint amount, uint minConversionRate) internal returns (uint) {\n        return kyberNetworkProxyContract.swapTokenToEther(token, amount, minConversionRate);\n    }\n\n    function tokenToToken(IERC20 srcToken, uint srcQty, IERC20 destToken, uint minConversionRate) internal returns (uint) {\n        return kyberNetworkProxyContract.swapTokenToToken(srcToken, srcQty, destToken, minConversionRate);\n    }\n}\n"
    },
    "contracts/incognito_proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./pause.sol\";\n\n/**\n * @dev Stores beacon and bridge committee members of Incognito Chain. Other\n * contracts can query this contract to check if an instruction is confimed on\n * Incognito\n */\ncontract IncognitoProxy is AdminPausable {\n    struct Committee {\n        address[] pubkeys; // ETH address of all members\n        uint startBlock; // The block that the committee starts to work on\n    }\n\n    Committee[] public beaconCommittees; // All beacon committees from genesis block\n    Committee[] public bridgeCommittees; // All bridge committees from genesis block\n\n    event BeaconCommitteeSwapped(uint id, uint startHeight);\n    event BridgeCommitteeSwapped(uint id, uint startHeight);\n\n    // error code\n    enum Errors {\n        SIGNATURE_DIMENSION_MISMATCH,\n        INSTRUCTION_NOT_APPROVED,\n        INSTRUCTION_INVALID,\n        COMMITTEE_HEIGHT_MISMATCH,\n        PREV_COMMITTEE_HEIGHT_MISMATCH,\n        SIGNATURE_INVALID,\n        MERKLE_PROOF_INVALID,\n        UNEXPECTED_ERROR\n    }\n\n    /**\n     * @dev Sets the genesis committees and the address of admin\n     * @notice Admin is the one responsible for the contract in case of emergency\n     * Here, they are authorized to Pause the contract, stopping new committees\n     * from being added to the contract\n     * Admin is authorized to Pause the contract at anytime for 1 year starting\n     * from the moment the contract is deployed\n     * Admin is also authorized to increase the expiration time if they need more\n     * time to implement a more decentralized failsafe mechanism\n     * @notice Admin can also be a smart contract implementing a DAO and making decisions through a voting system\n     * @param admin: ETH address\n     * @param beaconCommittee: genesis committee members of beacon chain\n     * @param bridgeCommittee: genesis committee members of bridge\n     */\n    constructor(\n        address admin,\n        address[] memory beaconCommittee,\n        address[] memory bridgeCommittee\n    ) public AdminPausable(admin) {\n        beaconCommittees.push(Committee({\n            pubkeys: beaconCommittee,\n            startBlock: 0\n        }));\n\n        bridgeCommittees.push(Committee({\n            pubkeys: bridgeCommittee,\n            startBlock: 0\n        }));\n    }\n\n    /**\n     * @dev Gets a beacon committee in the past\n     * @notice We need to implement this because the autogenerated getter returns only the startBlock\n     * @param i index of the committee to get\n     * @return the committee and their startBlock\n     */\n    function getBeaconCommittee(uint i) public view returns(Committee memory) {\n        return beaconCommittees[i];\n    }\n\n    /**\n     * @dev Gets a bridge committee in the past\n     * @notice the same as getBeaconCommittee but for bridge\n     */\n    function getBridgeCommittee(uint i) public view returns(Committee memory) {\n        return bridgeCommittees[i];\n    }\n\n    /**\n     * @dev Updates the latest committee of the bridge\n     * @notice This function takes a swap instruction on Incognito Chain, checks for its validity and stores the latest committee\n     * @notice This only works when the contract is not Paused\n     * @notice All params except inst are the list of 2 elements corresponding to the proof on beacon and bridge\n     * @param inst: the decoded instruction as a list of bytes\n     * @param instPaths: merkle path of the instruction\n     * @param instPathIsLefts: whether each node on the path is the left or right child\n     * @param instRoots: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdxs: indices of the validators who signed this block\n     * @param sigVs: part of the signatures of the validators\n     * @param sigRs: part of the signatures of the validators\n     * @param sigSs: part of the signatures of the validators\n     */\n    function swapBridgeCommittee(\n        bytes memory inst,\n        bytes32[][2] memory instPaths,\n        bool[][2] memory instPathIsLefts,\n        bytes32[2] memory instRoots,\n        bytes32[2] memory blkData,\n        uint[][2] memory sigIdxs,\n        uint8[][2] memory sigVs,\n        bytes32[][2] memory sigRs,\n        bytes32[][2] memory sigSs\n    ) public isNotPaused {\n        bytes32 instHash = keccak256(inst);\n\n        // Verify instruction on beacon\n        require(instructionApproved(\n            true,\n            instHash,\n            beaconCommittees[beaconCommittees.length-1].startBlock,\n            instPaths[0],\n            instPathIsLefts[0],\n            instRoots[0],\n            blkData[0],\n            sigIdxs[0],\n            sigVs[0],\n            sigRs[0],\n            sigSs[0]\n        ), errorToString(Errors.INSTRUCTION_NOT_APPROVED));\n\n        // Verify instruction on bridge\n        require(instructionApproved(\n            false,\n            instHash,\n            bridgeCommittees[bridgeCommittees.length-1].startBlock,\n            instPaths[1],\n            instPathIsLefts[1],\n            instRoots[1],\n            blkData[1],\n            sigIdxs[1],\n            sigVs[1],\n            sigRs[1],\n            sigSs[1]\n        ), errorToString(Errors.INSTRUCTION_NOT_APPROVED));\n\n        // Parse instruction and check metadata\n        (uint prevCommitteeStartHeight, uint startHeight) = extractMetaFromInstruction(inst, 71, 1);\n        // require(meta == 71 && shard == 1, errorToString(Errors.INSTRUCTION_INVALID));\n\n        uint myLatestCommitteeHeight = bridgeCommittees[bridgeCommittees.length-1].startBlock;\n        // Make sure 1 instruction can't be used twice (using startHeight)\n        require(prevCommitteeStartHeight == myLatestCommitteeHeight, errorToString(Errors.PREV_COMMITTEE_HEIGHT_MISMATCH));\n        require(startHeight > myLatestCommitteeHeight, errorToString(Errors.COMMITTEE_HEIGHT_MISMATCH));\n\n        // Swap committee\n        address[] memory pubkeys = extractCommitteeFromInstruction(inst);\n        bridgeCommittees.push(Committee({\n            pubkeys: pubkeys,\n            startBlock: startHeight\n        }));\n\n        emit BridgeCommitteeSwapped(bridgeCommittees.length, startHeight);\n    }\n\n    /**\n     * @dev Updates the latest committee of the beacon chain\n     * @notice This function takes a swap instruction on Incognito Chain, checks for its validity and stores the latest committee\n     * @notice This only works when the contract is not Paused\n     * @notice Swapping beacon committee doesn't require that the instruction is included in the bridge chain\n     * @notice All params are the same as swapBridgeCommittee\n     */\n    function swapBeaconCommittee(\n        bytes memory inst,\n        bytes32[] memory instPath,\n        bool[] memory instPathIsLeft,\n        bytes32 instRoot,\n        bytes32 blkData,\n        uint[] memory sigIdx,\n        uint8[] memory sigV,\n        bytes32[] memory sigR,\n        bytes32[] memory sigS\n    ) public isNotPaused {\n        bytes32 instHash = keccak256(inst);\n\n        // Verify instruction on beacon\n        require(instructionApproved(\n            true,\n            instHash,\n            beaconCommittees[beaconCommittees.length-1].startBlock,\n            instPath,\n            instPathIsLeft,\n            instRoot,\n            blkData,\n            sigIdx,\n            sigV,\n            sigR,\n            sigS\n        ), errorToString(Errors.INSTRUCTION_NOT_APPROVED));\n\n        // Parse instruction and check metadata and shardID\n        (uint prevCommitteeStartHeight, uint startHeight) = extractMetaFromInstruction(inst, 70, 1);\n        // require(meta == 70 && shard == 1 && numVals > 0, errorToString(Errors.INSTRUCTION_INVALID));\n\n        uint myLatestCommitteeHeight = beaconCommittees[beaconCommittees.length-1].startBlock;\n        // Make sure 1 instruction can't be used twice (using startHeight)\n        require(prevCommitteeStartHeight == myLatestCommitteeHeight, errorToString(Errors.PREV_COMMITTEE_HEIGHT_MISMATCH));\n        require(startHeight > myLatestCommitteeHeight, errorToString(Errors.COMMITTEE_HEIGHT_MISMATCH));\n\n        // Swap committee\n        address[] memory pubkeys = extractCommitteeFromInstruction(inst);\n        beaconCommittees.push(Committee({\n            pubkeys: pubkeys,\n            startBlock: startHeight\n        }));\n\n        emit BeaconCommitteeSwapped(beaconCommittees.length, startHeight);\n    }\n\n    /**\n     * @dev Checks if an instruction is confirmed on chain (beacon or bridge)\n     * @notice A confirmation means that the instruction is included in a block\n     * that has enough validators' signatures\n     * @param isBeacon: check on beacon or bridge\n     * @param instHash: keccak256 hash of the instruction's content\n     * @param blkHeight: height of the block containing the instruction\n     * @param instPath: merkle path of the instruction\n     * @param instPathIsLeft: whether each node on the path is the left or right child\n     * @param instRoot: root of the merkle tree contains all instructions\n     * @param blkData: merkle has of the block body\n     * @param sigIdx: indices of the validators who signed this block\n     * @param sigV: part of the signatures of the validators\n     * @param sigR: part of the signatures of the validators\n     * @param sigS: part of the signatures of the validators\n     * @return bool: whether the instruction is valid and confirmed\n     */\n    function instructionApproved(\n        bool isBeacon,\n        bytes32 instHash,\n        uint blkHeight,\n        bytes32[] memory instPath,\n        bool[] memory instPathIsLeft,\n        bytes32 instRoot,\n        bytes32 blkData,\n        uint[] memory sigIdx,\n        uint8[] memory sigV,\n        bytes32[] memory sigR,\n        bytes32[] memory sigS\n    ) public view returns (bool) {\n        // Find committee in charge of this block\n        address[] memory signers;\n        uint _;\n        if (isBeacon) {\n            (signers, _) = findBeaconCommitteeFromHeight(blkHeight);\n        } else {\n            (signers, _) = findBridgeCommitteeFromHeight(blkHeight);\n        }\n\n        // Extract signers that signed this block (require sigIdx to be strictly increasing)\n        require(sigV.length == sigIdx.length, errorToString(Errors.SIGNATURE_DIMENSION_MISMATCH));\n        require(sigV.length == sigR.length, errorToString(Errors.SIGNATURE_DIMENSION_MISMATCH));\n        require(sigV.length == sigS.length, errorToString(Errors.SIGNATURE_DIMENSION_MISMATCH));\n        for (uint i = 0; i < sigIdx.length; i++) {\n            if ((i > 0 && sigIdx[i] <= sigIdx[i-1]) || sigIdx[i] >= signers.length) {\n                return false;\n            }\n            signers[i] = signers[sigIdx[i]];\n        }\n\n        // Get double block hash from instRoot and other data\n        bytes32 blk = keccak256(abi.encodePacked(keccak256(abi.encodePacked(blkData, instRoot))));\n\n        // Check if enough validators signed this block\n        if (sigIdx.length <= signers.length * 2 / 3) {\n            return false;\n        }\n\n        // Check that signature is correct\n        require(verifySig(signers, blk, sigV, sigR, sigS), errorToString(Errors.SIGNATURE_INVALID));\n\n        // Check that inst is in block\n        require(instructionInMerkleTree(\n            instHash,\n            instRoot,\n            instPath,\n            instPathIsLeft\n        ), errorToString(Errors.MERKLE_PROOF_INVALID));\n\n        return true;\n    }\n\n    /**\n     * @dev Finds the beacon committee in charge of signing a block height\n     * @notice This functions does a binary search of all committees (since genesis block)\n     * @param blkHeight: to search for\n     * @return committee: address of the committee members\n     * @return id: index of the committee\n     */\n    function findBeaconCommitteeFromHeight(uint blkHeight) public view returns (address[] memory, uint) {\n        uint l = 0;\n        uint r = beaconCommittees.length;\n        require(r > 0, errorToString(Errors.UNEXPECTED_ERROR));\n        r = r - 1;\n        while (l != r) {\n            uint m = (l + r + 1) / 2;\n            if (beaconCommittees[m].startBlock <= blkHeight) {\n                l = m;\n            } else {\n                r = m - 1;\n            }\n        }\n        return (beaconCommittees[l].pubkeys, l);\n    }\n\n    /**\n     * @dev Finds the bridge committee in charge of signing a block height\n     * @notice The same as findBeaconCommitteeFromHeight but for bridge chain\n     */\n    function findBridgeCommitteeFromHeight(uint blkHeight) public view returns (address[] memory, uint) {\n        uint l = 0;\n        uint r = bridgeCommittees.length;\n        require(r > 0, errorToString(Errors.UNEXPECTED_ERROR));\n        r = r - 1;\n        while (l != r) {\n            uint m = (l + r + 1) / 2;\n            if (bridgeCommittees[m].startBlock <= blkHeight) {\n                l = m;\n            } else {\n                r = m - 1;\n            }\n        }\n        return (bridgeCommittees[l].pubkeys, l);\n    }\n\n    /**\n     * @dev Checks if a value is in a merkle tree\n     * @param leaf: the value to check\n     * @param root: of the merkle tree\n     * @param path: merkle path of the value to check\n     * @param left: whether each node on the path is the left or right child\n     * @return bool: whether the value is in the merkle tree\n     */\n    function instructionInMerkleTree(\n        bytes32 leaf,\n        bytes32 root,\n        bytes32[] memory path,\n        bool[] memory left\n    ) public pure returns (bool) {\n        require(left.length == path.length, errorToString(Errors.MERKLE_PROOF_INVALID));\n        bytes32 hash = leaf;\n        for (uint i = 0; i < path.length; i++) {\n            if (left[i]) {\n                hash = keccak256(abi.encodePacked(path[i], hash));\n            } else if (path[i] == 0x0) {\n                hash = keccak256(abi.encodePacked(hash, hash));\n            } else {\n                hash = keccak256(abi.encodePacked(hash, path[i]));\n            }\n        }\n        return hash == root;\n    }\n\n    /**\n     * @dev Extracts the metadata of a swap instruction\n     * @param inst: the full instruction, containing both metadata and body\n     * @param expectedMeta: required type of the instruction, 70 for swapping beacon and 71 for bridge\n     * @param expectedShard: required ID of the Incognito shard containing the instruction, must be 1\n     * @return height: the starting block that the committee is responsible for\n     * @return prevHeight: the starting block of the signing committee for this instruction\n     */\n    function extractMetaFromInstruction(bytes memory inst, uint8 expectedMeta, uint8 expectedShard) public pure returns (uint, uint) {\n        require(inst.length >= 0x62, errorToString(Errors.INSTRUCTION_INVALID)); // 0x02 bytes for meta and shard, 0x20 each for height and numVals\n        uint8 meta = uint8(inst[0]);\n        uint8 shard = uint8(inst[1]);\n        uint height;\n        uint prevHeight;\n        assembly {\n            // skip first 0x20 bytes (stored length of inst)\n            prevHeight := mload(add(inst, 0x22)) // [2:34]\n            height := mload(add(inst, 0x42)) // [34:66]\n        }\n        require(meta == expectedMeta && shard == expectedShard, errorToString(Errors.INSTRUCTION_INVALID));\n        return (prevHeight, height);\n    }\n\n    /**\n     * @dev Extracts the committee (body) from a swap instruction\n     * @param inst: the full instruction, containing both metadata and body\n     * @return committee: address of the committee members\n     */\n    function extractCommitteeFromInstruction(bytes memory inst) public pure returns (address[] memory) {\n        uint numVals;\n        assembly {\n            numVals := mload(add(inst, 0x62))\n        }\n\n        require(numVals > 0, errorToString(Errors.INSTRUCTION_INVALID));\n        require(inst.length == 0x62 + numVals * 0x20, errorToString(Errors.INSTRUCTION_INVALID));\n        address[] memory addr = new address[](numVals);\n        address tmp;\n        for (uint i = 0; i < numVals; i++) {\n            assembly {\n                // skip first 0x20 bytes (stored length of inst)\n                // also, skip the next 0x62 bytes (stored metadata)\n                tmp := mload(add(add(inst, 0x82), mul(i, 0x20))) // 67+i*32\n            }\n            addr[i] = tmp;\n        }\n        return addr;\n    }\n\n    /**\n     * @dev Verifies that the signatures for a message are correct\n     * @param msgHash: the message to be verify\n     * @param v: part of the signatures\n     * @param r: part of the signatures\n     * @param s: part of the signatures\n     * @return bool: whether all signatures are correct\n     */\n    function verifySig(\n        address[] memory committee,\n        bytes32 msgHash,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) public pure returns (bool) {\n        require(v.length == r.length, errorToString(Errors.SIGNATURE_DIMENSION_MISMATCH));\n        require(v.length == s.length, errorToString(Errors.SIGNATURE_DIMENSION_MISMATCH));\n        for (uint i = 0; i < v.length; i++){\n            address recoveredAddress = ecrecover(msgHash, v[i], r[i], s[i]);\n            if (recoveredAddress == address(0x0) || recoveredAddress != committee[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev convert enum to string value\n     */\n     function errorToString(Errors error) internal pure returns(string memory) {\n        uint8 erroNum = uint8(error);\n        uint maxlength = 10;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (erroNum != 0) {\n            uint8 remainder = erroNum % 10;\n            erroNum = erroNum / 10;\n            reversed[i++] = byte(48 + remainder);\n        }\n        bytes memory s = new bytes(i + 1);\n        for (uint j = 0; j <= i; j++) {\n            s[j] = reversed[i - j];\n        }\n        return string(s);\n    }\n}\n"
    },
    "contracts/pause.sol": {
      "content": "pragma solidity ^0.6.12;\n\ncontract AdminPausable {\n    address public admin;\n    address public successor;\n    bool public paused;\n    uint public expire;\n\n    constructor(address _admin) public {\n        admin = _admin;\n        paused = false;\n        expire = block.timestamp + 365 * 1 days;\n    }\n\n    event Paused(address pauser);\n    event Unpaused(address pauser);\n    event Extend(uint ndays);\n    event Claim(address claimer);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"not admin\");\n        _;\n    }\n\n    modifier isPaused() {\n        require(paused, \"not paused right now\");\n        _;\n    }\n\n    modifier isNotPaused() {\n        require(!paused, \"paused right now\");\n        _;\n    }\n\n    modifier isNotExpired() {\n        require(block.timestamp < expire, \"expired\");\n        _;\n    }\n\n    function retire(address _successor) public onlyAdmin isNotExpired {\n        successor = _successor;\n    }\n\n    function claim() public isNotExpired {\n        require(msg.sender == successor, \"unauthorized\");\n        admin = successor;\n        emit Claim(admin);\n    }\n\n    function extend(uint n) public onlyAdmin isNotExpired {\n        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n        expire = expire + n * 1 days;\n        emit Extend(n);\n    }\n\n    function pause() public onlyAdmin isNotPaused isNotExpired {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyAdmin isPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}"
    },
    "contracts/proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n * \n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n * \n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     * \n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal virtual view returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     * \n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () payable external {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () payable external {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     * \n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}"
    },
    "contracts/upgradableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nimport \"./proxy.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n * {TransparentUpgradeableProxy}.\n */\ncontract UpgradeableProxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     * \n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) public payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if(_data.length > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success,) = _logic.delegatecall(_data);\n            require(success, \"DELEGATECALL failed\");\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal override view returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * \n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n    \n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}"
    },
    "contracts/transparentUpgraded.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nimport \"./upgradableProxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n * \n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n * \n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n * \n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    constructor(address _logic, address _admin, address _incognito, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        assert(_SUCCESSOR_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.successor\")) - 1));\n        assert(_PAUSED_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.paused\")) - 1));\n        assert(_INCOGNITO_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.incognito.\")) - 1));\n        _setAdmin(_admin);\n        _setIncognito(_incognito);\n    }\n\n    /**\n     * @dev Emitted when the successor account has changed.\n     */\n    event SuccessorChanged(address previousSuccessor, address newSuccessor);\n    \n    /**\n     * @dev Emitted when the incognito proxy has changed.\n     */\n    event IncognitoChanged(address previousIncognito, address newIncognito);\n\n    /**\n     * @dev Emitted when the successor claimed thronze.\n     **/\n    event Claim(address claimer);\n    \n    /**\n     * @dev Emitted when the admin pause contract.\n     **/\n    event Paused(address admin);\n    \n    /**\n     * @dev Emitted when the admin unpaused contract.\n     **/\n    event Unpaused(address admin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.successor\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _SUCCESSOR_SLOT = 0x7b13fc932b1063ca775d428558b73e20eab6804d4d9b5a148d7cbae4488973f8;\n\n    /**\n     * @dev Storage slot with status paused or not.\n     * This is the keccak-256 hash of \"eip1967.proxy.paused\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _PAUSED_SLOT = 0x8dea8703c3cf94703383ce38a9c894669dccd4ca8e65ddb43267aa0248711450;\n    \n    /**\n     * @dev Storage slot with the incognito proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.incognito.\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _INCOGNITO_SLOT = 0x62135fc083646fdb4e1a9d700e351b886a4a5a39da980650269edd1ade91ffd2;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     * \n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     * \n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address) {\n        return _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     * \n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     * \n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Returns the current successor.\n     * \n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     * \n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x7b13fc932b1063ca775d428558b73e20eab6804d4d9b5a148d7cbae4488973f8`\n     */\n    function successor() external ifAdmin returns (address) {\n        return _successor();\n    }\n\n    /**\n     * @dev Returns the current paused value.\n     * \n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     * \n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x8dea8703c3cf94703383ce38a9c894669dccd4ca8e65ddb43267aa0248711450`\n     */\n    function paused() external ifAdmin returns (bool) {\n        return _paused();\n    }\n    \n    /**\n     * @dev Returns the current incognito proxy.\n     * \n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     * \n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x6c1fc16c781d41e11abf5619c272a94b10ccafab380060da4bd63325467b854e`\n     */\n    function incognito() external ifAdmin returns (address) {\n        return _incognito();\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     * \n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     * \n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeTo(newImplementation);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success,) = newImplementation.delegatecall(data);\n        require(success, \"DELEGATECALL failed\");\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Returns the current successor.\n     */\n    function _successor() internal view returns (address sor) {\n        bytes32 slot = _SUCCESSOR_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sor := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 successor slot.\n     */\n    function _setSuccesor(address newSuccessor) private {\n        bytes32 slot = _SUCCESSOR_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newSuccessor)\n        }\n    }\n\n    /**\n     * @dev Returns the current paused value.\n     */\n    function _paused() internal view returns (bool psd) {\n        bytes32 slot = _PAUSED_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            psd := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new paused value in the EIP1967 paused slot.\n     */\n    function _setPaused(bool psd) private {\n        bytes32 slot = _PAUSED_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, psd)\n        }\n    }\n    \n    /**\n     * @dev Returns the current incognito proxy.\n     */\n    function _incognito() internal view returns (address icg) {\n        bytes32 slot = _INCOGNITO_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            icg := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 incognito proxy slot.\n     */\n    function _setIncognito(address newIncognito) private {\n        bytes32 slot = _INCOGNITO_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newIncognito)\n        }\n    }\n\n    /**\n     * @dev Admin retire to prepare transfer thronze to successor.\n     */\n    function retire(address newSuccessor) external ifAdmin {\n        require(newSuccessor != address(0), \"TransparentUpgradeableProxy: successor is the zero address\");\n        emit SuccessorChanged(_successor(), newSuccessor);\n        _setSuccesor(newSuccessor);\n    }\n\n    /**\n     * @dev Successor claims thronze.\n     */\n    function claim() external {\n        if (msg.sender == _successor()) {\n            emit Claim(_successor());\n            _setAdmin(_successor());\n        } else{\n            _fallback();\n        }\n    }\n    \n    /**\n     * @dev Admin pause contract.\n     */\n    function pause() external ifAdmin {\n        require(!_paused(), \"TransparentUpgradeableProxy: contract paused already\");\n        _setPaused(true);\n    }\n    \n    /**\n     * @dev Admin unpause contract.\n     */\n    function unpause() external ifAdmin {\n        require(_paused(), \"TransparentUpgradeableProxy: contract not paused\");\n        _setPaused(false);\n    }\n    \n     /**\n     * @dev Admin upgrade incognito proxy.\n     */\n    function upgradeIncognito(address newIncognito) external ifAdmin {\n        require(newIncognito != address(0), \"TransparentUpgradeableProxy: incognito proxy is the zero address\");\n        emit IncognitoChanged(_incognito(), newIncognito);\n        _setIncognito(newIncognito);\n    }\n    \n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal override virtual {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        require(!_paused(), \"TransparentUpgradeableProxy: contract is paused\");\n        super._beforeFallback();\n    }\n}"
    },
    "contracts/vaultHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract VaultHelper {\n    enum Prefix {\n        EXECUTE_SIGNATURE,\n        REQUEST_WITHDRAW_SIGNATURE\n    }\n    \n    struct PreSignData {\n        Prefix prefix;\n        address token;\n        bytes timestamp;\n        uint amount;\n    }\n\n    function newPreSignData(Prefix prefix, address token, bytes calldata timestamp, uint amount) pure public returns (PreSignData memory) {\n        PreSignData memory psd = PreSignData(prefix, token, timestamp, amount);\n        return psd;\n    }\n\n    function _buildPreSignData(Prefix prefix, address token, bytes calldata timestamp, uint amount) pure public {\n        // PreSignData memory psd = PreSignData(prefix, token, timestamp, amount);\n        // return psd;\n    }\n\n    function _buildSignRequestWithdraw(PreSignData memory psd, string calldata incognitoAddress) pure public returns (bytes32) {\n        // do nothing\n        require(psd.prefix == Prefix.REQUEST_WITHDRAW_SIGNATURE);\n        bytes32 temp = keccak256(abi.encode(psd, incognitoAddress));\n        return temp;\n    }\n\n    function _buildSignExecute(PreSignData memory psd, address recipientToken, address exchangeAddress, bytes calldata callData) pure public returns (bytes32) {\n        // do nothing\n        require(psd.prefix == Prefix.EXECUTE_SIGNATURE);\n        bytes32 temp = keccak256(abi.encode(psd, recipientToken, exchangeAddress, callData));\n        return temp;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}